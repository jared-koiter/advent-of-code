function Parse-Directories {
    [CmdletBinding()]
    param (
        $CmdList
    )

    $directories = @{
        '/' = [PSCustomObject]@{
            Parent = $null
            Size = 0
        }
    }
    $currDirKey = '/'

    for ($i = 0; $i -lt $CmdList.Count; $i++) {
        $null, $commandType, $destination = ($CmdList[$i] -split ' ')

        if ($commandType -eq 'cd') {
            if ($destination -eq '..') {
                if ($directories.$currDirKey.Parent) {
                    $currDirKey = $directories.$currDirKey.Parent
                }
                else {
                    throw "Cannot go up from directory $currDirKey, no parent directory defined"
                }
            }
            elseif ($destination -eq '/') {
                $currDirKey = '/'
            }
            else {
                $fullDestination = "$currDirKey-$destination"
                if (-not ($directories.$fullDestination)) {
                    throw "Could not cd to $fullDestination from $currDirKey, directory was not previously found by ls"
                }
                $currDirKey = $fullDestination
            }
        }
        elseif ($commandType -eq 'ls') {
            # read the output of ls and process them for the current directory
            while (($i -lt $PuzzleInput.Count - 1) -and ($CmdList[$i+1][0] -ne '$')) {
                # a/b is either dir/name or size/filename
                $a, $b = $CmdList[$i+1] -split ' '
                if ($a -eq 'dir') {
                    # add directory to tracking list if it doesn't already exist
                    # use full path as key to handle cases of duplicate dir names in multiple parents
                    $fullPath = "$currDirKey-$b"
                    if (-not ($directories.$fullPath)) {
                        $directories.$fullPath = [PSCustomObject]@{
                            Parent = $currDirKey
                            Size = 0
                        }
                    }
                }
                else {
                    # add filesize to current directory
                    $directories.$currDirKey.Size += $a

                    # add filesize to parent directories recursively
                    $parentPointer = $directories.$currDirKey.Parent
                    while ($parentPointer) {
                        $directories.$parentPointer.Size += $a
                        $parentPointer = $directories.$parentPointer.Parent
                    }
                }

                $i++
            }
        }
        else {
            throw "Unrecognized command type '$commandType', cannot parse"
        }
    }

    return $directories
}

# sanity check function to get the total sum of all files directly
# this output should equal the '/' size generated by the Parse-Directories function
function Get-TotalFilesize {
    [CmdletBinding()]
    param (
        $CmdList
    )

    $totalSize = 0

    foreach ($cmd in $CmdList) {
        if ([int]::TryParse((($cmd -split ' ')[0]), [ref]$output)) {
            $totalSize += $output
        }
    }

    return $totalSize
}

function Run-Puzzle1 {
    [CmdletBinding()]
    param (
        $PuzzleInput
    )

    $directories = Parse-Directories -CmdList $PuzzleInput

    # uncomment to add sanity check into parsing
    #if ($directories.'/'.Size -ne (Get-TotalFilesize -CmdList $PuzzleInput)) {
    #    throw "Total file size does not match parsed file tree size, double check parsing function"
    #}

    $maxSize = 100000
    return ($directories.Keys | Foreach-Object { $directories.$_.Size } | Where-Object { $_ -le $maxSize } | Measure-Object -Sum).Sum
}

function Run-Puzzle2 {
    [CmdletBinding()]
    param (
        $PuzzleInput
    )

    $directories = Parse-Directories -CmdList $PuzzleInput

    $totalDisk = 70000000
    $targetFree = 30000000
    $currentFree = ($totalDisk - $directories.'/'.Size)

    return $directories.Keys |
        Foreach-Object { $directories.$_.Size } |
        Sort-Object |
        Where-Object { ($_ + $currentFree) -ge $targetFree } |
        Select-Object -First 1
}

[string[]]$puzzleInput = Get-Content .\input.txt

$puzzle1Timer = [System.Diagnostics.Stopwatch]::StartNew()
$output = Run-Puzzle1 -PuzzleInput $puzzleInput
$puzzle1Timer.Stop()

Write-Host "Puzzle 1 Answer: $output"
Write-Host "Time: $($puzzle1Timer.ElapsedMilliseconds) ms"

$puzzle2Timer = [System.Diagnostics.Stopwatch]::StartNew()
$output = Run-Puzzle2 -PuzzleInput $puzzleInput
$puzzle2Timer.Stop()

Write-Host "Puzzle 2 Answer: $output"
Write-Host "Time: $($puzzle2Timer.ElapsedMilliseconds) ms"
